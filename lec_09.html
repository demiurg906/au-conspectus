<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<title>Конспект по алгоритмам. Strongly connected components</title>
<!-- Search Engine -->
<meta name="description" content="Strongly connected components Утверждения: Если рассматривать любой  ациклический граф , то в нем есть сток и исток Если граф  G  ациклический, то тогда и ">
<meta name="image" content="https://i.imgur.com/HunB6ar.jpg">
<!-- Schema.org for Google -->
<meta itemprop="name" content="Конспект по алгоритмам. Strongly connected components">
<meta itemprop="description" content="Strongly connected components Утверждения: Если рассматривать любой  ациклический граф , то в нем есть сток и исток Если граф  G  ациклический, то тогда и ">
<meta itemprop="image" content="https://i.imgur.com/HunB6ar.jpg">
<!-- Twitter -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Конспект по алгоритмам. Strongly connected components">
<meta name="twitter:description" content="Strongly connected components Утверждения: Если рассматривать любой  ациклический граф , то в нем есть сток и исток Если граф  G  ациклический, то тогда и ">
<meta name="twitter:image:src" content="https://i.imgur.com/HunB6ar.jpg">
<!-- Twitter - Article -->
<!-- Open Graph general (Facebook, Pinterest & Google+) -->
<meta property="og:title" content="Конспект по алгоритмам. Strongly connected components">
<meta property="og:description" content="Strongly connected components Утверждения: Если рассматривать любой  ациклический граф , то в нем есть сток и исток Если граф  G  ациклический, то тогда и ">
<meta property="og:image" content="https://i.imgur.com/HunB6ar.jpg">
<meta property="og:type" content="article">
<!-- Open Graph - Article -->

<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="assets/style.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js" integrity="sha256-MRn7pN9LOBMrkp+8F2t5xb/92V1irzXp/dl5tUTwEgE=" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" integrity="sha256-tAflq+ymku3Khs+I/WcAneIlafYgDiOQ9stIHH985Wo=" crossorigin="anonymous" />
<script src="assets/xpath.js" type="text/javascript"></script>
<script>newIssue="https://github.com/xamgore/au-conspectus/issues/new"</script>
<script src="assets/load.js"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax:    {
    inlineMath:  [['$','$'],  ['\\(','\\)']],
    displayMath: [["$$","$$"],["\\[","\\]"]],
    displayAlign: "center"
    // processEscapes: true
  },
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
         SVG: { linebreaks: { automatic: true } }
});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
</script>
</head>
<body>
  <div id="mistake">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 402.938 402.938"><path d="M401.785 33.437C399.28 18.683 389.61 16.48 384.07 16.48c-22.935 0-65.053 36.684-109.644 75.52-18.23 15.88-37.083 32.3-53.502 45.048-5.858 4.548-11.803 9.103-18.097 13.924-31.276 23.96-66.726 51.12-94.16 80.356-26.887 28.65-42.593 55.62-47.676 81.98L4.12 364.683c-5.122 4.628-5.523 12.532-.896 17.655 2.468 2.732 5.867 4.12 9.28 4.12 2.987 0 5.984-1.063 8.375-3.223l47.816-43.194c2.31.634 5.016.963 8.19.963 27.39 0 93.534-24.866 153.857-57.84l6.043-3.305L226.11 269.8l17.888 5.932 1.947-1.13c15.867-9.21 30.165-18.41 42.496-27.338 2.19-1.586 4.45-3.292 7.115-5.372l3.87-3.02-11.223-14.93 20.26 7.21 2.218-2.02c15.51-14.13 29.805-30.467 42.486-48.554l2.428-3.462-18.606-18.342 25.257 8.17 2.054-3.37c28.307-46.454 43.02-97.535 37.485-130.137z"/></svg>
  </div>

  <article class="content">
      
      <div class="navigation">
        <a href="https://xamgore.github.io/au-conspectus/lec_08.html">← взад</a>
        <a href="index.html">на главную</a>
        <a href="None"></a>
      </div>
      
      <h2 id="strongly-connected-components"><a aria-hidden="true" href="#strongly-connected-components"><span class="icon icon-link"></span></a>Strongly connected components</h2>
<p><strong>Утверждения:</strong></p>
<ul>
<li>Если рассматривать любой <a class="term">ациклический граф</a>, то в нем есть сток и исток</li>
<li>Если граф <span class="inlineMath">$G$</span> ациклический, то тогда и только тогда <span class="inlineMath">$G^R$</span> (граф с перевернутыми стрелками) тоже ациклический (и наоборот, если есть цикл в одном графе, то есть и в другом)</li>
<li><span class="inlineMath">$G^R$</span> можно построить за <span class="inlineMath">$O(|V|+|E|)$</span> по <span class="inlineMath">$G$</span>, заданному списком смежности.</li>
</ul>
<p><strong>Компонента сильной связности</strong> — это максимальное подвключение подмножества <span class="inlineMath">$V$</span> такое, что <span class="inlineMath">$\forall u, v \in V$</span> существует путь <span class="inlineMath">$u\rightarrow v \rightarrow u$</span>.</p>
<p><strong>Метаграф</strong> — граф, в котором все компоненты сильной связности заменены на единичные вершины (с сохранением ребер между компонентами). Если есть несколько ребер между двумя компонентами, то, в зависимости от задачи, можно либо их склеить в одно ребро, либо оставить все.</p>
<p><strong>Утверждение:</strong> — метаграф ациклический.
<strong>Доказательство:</strong> — если бы в нем был цикл, то несколько компонент сильной связности склеились бы в одну.</p>
<p><strong>Утверждение:</strong> — есть две вершины <span class="inlineMath">$U$</span> и <span class="inlineMath">$V$</span> (в метаграфе), которые задают две компоненты сильной связности, <span class="inlineMath">$(U \rightarrow V) \in H$</span> (<span class="inlineMath">$H$</span> — множество ребер метаграфа).
<span class="inlineMath">$\max\limits_{u \in U}\{post[u]\} > \max\limits_{v \in V}\{post[v]\}$</span> (<span class="inlineMath">$post$</span> — время выхода из вершины при обходе DFS).
<strong>Доказательство:</strong>
1. Сначала попали в <span class="inlineMath">$U \rightarrow$</span> ОК (у одной из вершин <span class="inlineMath">$u$</span> время выхода будет больше, чем для всех <span class="inlineMath">$v$</span>)
2. Сначала попали в <span class="inlineMath">$V \rightarrow$</span> не попали в <span class="inlineMath">$U$</span> (туда попадем только на следующем вызове DFS <span class="inlineMath">$\rightarrow$</span> для всех <span class="inlineMath">$u$</span> время выхода больше любого времени <span class="inlineMath">$v$</span>).</p>
<p><strong>Утверждение:</strong> вершина с максимальным <span class="inlineMath">$post$</span> лежит в компоненте истоке.</p>
<p><strong>Утверждение:</strong> если отсортировать вершины по убыванию <span class="inlineMath">$post$</span>, то получится топологическая сортировка на метаграфе.</p>
<p><strong>Алгоритм:</strong> отсортируем вершины по убыванию <span class="inlineMath">$post$</span> и запустим обычный поиск компонент связности в перевернутом графе.</p>
<pre><code class="language-python">def scc(g):
    dfs(g)
    g_r = revert(g)
    sort(g_r.v, maxpost, reverse=True)  # сортируем вершины графа g_r
    # можно получить отсортированный массив прямо внутри dfs
    cc(g_r)  # поиск компонент
</code></pre>
<p>Время работы <span class="inlineMath">$O(|V| + |E|)$</span> (можно использовать сортировку подсчетом, что сортировать за <span class="inlineMath">$O(|V|)$</span>).</p>
<h2 id="Кратчайшие-пути"><a aria-hidden="true" href="#Кратчайшие-пути"><span class="icon icon-link"></span></a>Кратчайшие пути</h2>
<h3 id="Поиск-в-ширину"><a aria-hidden="true" href="#Поиск-в-ширину"><span class="icon icon-link"></span></a>Поиск в ширину</h3>
<pre><code class="language-python">def bfs(g, w):  # w — вершина, откуда запускаем обход
    q = deque()
    dist = [inf for v in g.f]  # массив расстояний
    prev = [0 for v in g.f]    # восстановление пути
    dist[w] = 0
    q.append(v)
    while q:
        v = q.popleft()
        for u in g.v[v].neighbours:
            if dist[u] &#x3C; inf:
                dist[u] = dist[v] + 1
                prev[u] = v
                q.append(u)
    return dist, prev
</code></pre>
<p>Время работы <span class="inlineMath">$O(|V| + |E|)$</span></p>
<p><strong>Утверждение:</strong> <span class="inlineMath">$\forall u: \ d[u] = \text{dist}(w, u)$</span>
<strong>База:</strong> <span class="inlineMath">$u=w \Rightarrow d[w] = \text{dist}(w, w) = 0$</span>
<strong>И.п.:</strong> верно на расстояниях <span class="inlineMath">$\leq k \Rightarrow$</span> верно на расстоянии <span class="inlineMath">$k+1$</span>. Все вершины на расстоянии <span class="inlineMath">$k+1$</span> являются соседями вершин на расстоянии <span class="inlineMath">$k$</span> (достаточно очевидно).</p>
<p><strong>Утверждение:</strong> пусть <span class="inlineMath">$\Pi = (v, v_1, v_2,\ ...\ ,v_k, u)$</span> — кратчайший путь <span class="inlineMath">$v \rightarrow u$</span>. Тогда для <span class="inlineMath">$\forall i, j: \ i &#x3C; j:\ \Pi'=(v_i, v_{i+1},\ ...\ , v_j)$</span> — кратчайший путь <span class="inlineMath">$v_i\rightarrow v_j$</span>.</p>
<p>BFS Не работает для поиска кратчайшего пути, если граф взвешенный.</p>
<p>Можно добавить фиктивных вершин (ребро веса 5 — четыре дополнительных вершины веса 1 на это ребро).
Минусы:</p>
<ul>
<li>требует целых/дробных весов</li>
<li>не работает на иррациональных числах (на это пофиг, т.к. иррациональность не представима на машине Тьюринга)</li>
<li>требует много памяти на ребрах с большим весом</li>
</ul>
<h3 id="Алгоритм-Дейкстры"><a aria-hidden="true" href="#Алгоритм-Дейкстры"><span class="icon icon-link"></span></a>Алгоритм Дейкстры</h3>
<p>Работает для графов с неотрицательными ребрами.</p>
<p>Для реализации нужна очередь с приоритетами с операциями:</p>
<ul>
<li><code>extract_min()</code></li>
<li><code>change_priority(value, key)</code></li>
<li><code>insert(value, priority)</code></li>
</ul>
<pre><code class="language-python">def dijkstra(g, s):  # s — стартовая вершина
    dist = [inf for v in g.v]
    prev = [0 for  in g.v]
    dist[s] = 0
    q = priority_queue()
    q.insert(s, 0)
    while q:
        v = q.extract_min()
        for u in g.v[v].neighbours:
            if dist[u] == inf:
                dist[u] = dist[v] + g.w[v]
                prev[u] = v
                q.insert(u, dist[u])
            elif dist[u] > dist[v] + g.w[v]:
                dist[u] = dist[v] + g.w[v]
                prev[u] = v
                q.change_priority(u, dist[u])
            # если запилить такую очередь, что каждое value
            # представлено только 1 раз, и q.insert в случае
            # чего перезапишет старый приоритет, то можно
            # обойтись только одним if'ом
    return dist, prev
</code></pre>
<p><strong>Лемма:</strong> алгоритм Дейскстры корректен. <span class="inlineMath">$\forall u: \ d[u] = \text{dist}(w, u)$</span>.
<strong>Доказательство:</strong></p>
<ul>
<li>Для вершин из другой компоненты связности корректность очевидна.</li>
<li>
<p>Ведем три множества:</p>
<ol>
<li><span class="inlineMath">$S$</span>  — вершины, которые мы уже обработали (которые вытащили из очереди)</li>
<li><span class="inlineMath">$R$</span>  — вершины, которые сейчас в очереди</li>
<li><span class="inlineMath">$T$</span>  — вершины, с расстоянием равным <span class="inlineMath">$+\infty$</span>
Вершины в <span class="inlineMath">$R$</span> — соседи вершин из <span class="inlineMath">$S$</span>.
<strong>Утверждение:</strong> если <span class="inlineMath">$v$</span> переходит из <span class="inlineMath">$R$</span> в <span class="inlineMath">$S \Rightarrow \ d[v] = \text{dist}(s, v)$</span>
<strong>Доказательство:</strong> пусть <span class="inlineMath">$v$</span> — вершина в очереди с самым маленьким приоритетом.
<strong>И.п.:</strong>  для всех вершин в <span class="inlineMath">$S$</span> расстояние вычисленно корректно. Докажем от противного: пусть <span class="inlineMath">$\Pi = (s, v1, \ ... \, v_k, v)$</span> — более короткий путь <span class="inlineMath">$s\rightarrow v$</span>. Рассмотрим первую вершину этого пути, которая лежит в <span class="inlineMath">$R$</span>. Расстояние от нее до <span class="inlineMath">$s$</span> больше, чем предпологаемое расстояние до <span class="inlineMath">$v$</span>, которое лежит в очереди. Противоречие.</li>
</ol>
</li>
</ul>
<p>Сложность алгоритма: <span class="inlineMath">$O(|V|) + O(|V|\cdot \text{insert}) + O(|V|\cdot \text{extract\_min}) + O(|E|\cdot \text{change\_priority})$</span></p>
<p>Если брать очередь на куче, то сложность <span class="inlineMath">$O((V+E)\log V)$</span>.
Если брать очередь на массиве, то сложность <span class="inlineMath">$O(V^2+E)$</span> (если граф простой, то <span class="inlineMath">$+E$</span> можно пренебречь).</p>
<p>Для неплотных <span class="inlineMath">$\left(E = O\left(\frac{V^2}{\log V}\right)\right)$</span> графов лучше использовать кучу, для плотных (<span class="inlineMath">$E \thicksim V^2$</span>) — массив.</p>
<p><strong>Tip:</strong> можно улучшить, если использовать <span class="inlineMath">$d$</span>-ичную кучу. <span class="inlineMath">$d \approx \frac EV$</span>.</p>
<p>(картинкА)</p>
<h4 id="d-ичная-куча"><a aria-hidden="true" href="#d-ичная-куча"><span class="icon icon-link"></span></a>d-ичная куча</h4>
<p>Если юзануть <span class="inlineMath">$d$</span>-ичную кучу, то выйдет <span class="inlineMath">$n * d \cdot \log_d n$</span> — при extract_min. При insert'e: <span class="inlineMath">$n * \log_d n$</span>, а decrease_key: <span class="inlineMath">$m * \log_d n$</span>. Суммарная сложность: <span class="inlineMath">$O((n\cdot d + m) \log_d n)$</span>.</p>
<p>Утверждается, что если <span class="inlineMath">$d \approx \frac{m}{n}$</span>, то мы получим самое оптимальное решение.</p>
<ol>
<li>
<p><span class="inlineMath">$\frac{m}{n} = O(1)$</span>, т.е. <span class="inlineMath">$m \approx n$</span>, т.е. <span class="inlineMath">$d = const \Rightarrow O((n+m) \log n) = O(n \log n)$</span></p>
</li>
<li>
<p>Пусть граф полный. <span class="inlineMath">$m = \Omega(n^2)$</span>, тогда <span class="inlineMath">$(d =) \frac{m}{n} = n \Rightarrow O(m) = O(n^2)$</span>. Это то же что мы получали при реализации на массиве.</p>
</li>
<li>
<p><span class="inlineMath">$m = \Theta(n^{1+eps}), 0 &#x3C; eps &#x3C; 1$</span>. Тогда <span class="inlineMath">$d = n^{eps}$</span>. Итого <span class="inlineMath">$O(n\cdot d + m) \log_d n) = O((n\cdot n^{eps} + m) \cdot \log_{n^{eps}} n)$</span>, расписав последний логарифм как <span class="inlineMath">$\frac{\log n}{eps \cdot \log n} = \frac{1}{eps}$</span> получаем <span class="inlineMath">$O(n^{1+eps}) = O(m)$</span>.</p>
</li>
</ol>
<h2 id="Кратчайшие-пути-в-графах-с-отрицательными-весами"><a aria-hidden="true" href="#Кратчайшие-пути-в-графах-с-отрицательными-весами"><span class="icon icon-link"></span></a>Кратчайшие пути в графах с отрицательными весами</h2>
<p>Дейкстра не работает (был пример),</p>
<pre><code>* --5-->*
  \     \-6
   10----->*
</code></pre>
<p><strong>Утверждение</strong>. Если в графе есть отрицательный цикл <span class="inlineMath">$\Rightarrow$</span> кратчайшие пути не определены.</p>
<p>Это достаточно очевидно утверждение. Мы бы тогда смогли построить путь из <span class="inlineMath">$s$</span> в <span class="inlineMath">$t$</span> отрицательной длины, и каждый раз бы пробовали его уменьшать (до <span class="inlineMath">$-\infty$</span>).</p>
<p>Напоним про операцию релаксации:</p>
<pre><code>  u --------> v
 d[u]         d[v]
</code></pre>
<pre><code class="language-python">if d[u] + w(u, v) &#x3C; d[v]:
    d[v] = d[u] + w(u, v)
</code></pre>
<p>То есть если пройти по ребру <span class="inlineMath">$(u, v)$</span>, то я смогу уменьшить суммарный вес пути. Поэтому до <span class="inlineMath">$v$</span> лучше идти через <span class="inlineMath">$u$</span>.</p>
<p><strong>Утверждение</strong>. Релаксация только "улучшает" пути (т.е. не увеличивает). Это видно из определения выше.</p>
<p><strong>Утверждение</strong>: Релаксация корректна, <span class="inlineMath">$d[v] \geqslant dist(s, v)$</span>. То есть релаксация не получит путь короче чем существует в графе.</p>
<p><strong>Лемма</strong>: Пусть <span class="inlineMath">$\pi$</span> — кратчайший путь <span class="inlineMath">$(s, v_1, v_2, \ldots, v_k, t)$</span> из <span class="inlineMath">$s$</span> в <span class="inlineMath">$t$</span>. Тогда если мы сделаем релаксации для всех рёбер вдоль пути <span class="inlineMath">$\Rightarrow$</span> <span class="inlineMath">$d[t] = dist(s, t)$</span>.</p>
<p>Рассмотрим перое ребро из <span class="inlineMath">$s$</span>: <span class="inlineMath">$(s, v_1)$</span>. Если посчитаем релаксацию для этого ребра, то мы правильно посчитаем расстояние до <span class="inlineMath">$v_1$</span>. По индукции и по следующему утверждению пути лемма доказана.</p>
<!-- Тогда $d[s] = 0$, $d[v_1] = \infty$.  -->
<p><strong>Утверждение</strong>: Если есть кратчайший путь <span class="inlineMath">$\pi$</span>, то любой его подпуть тоже кратчайший. (Кстати, это место сломается, если мы ищем кратчайшие пустые пути). Если бы существовал не кратчайший подпуть, то там был бы цикл, т.е. и оригинальный путь не был бы кратчайшим.</p>
<h3 id="Алгоритм-Белмана-Форда"><a aria-hidden="true" href="#Алгоритм-Белмана-Форда"><span class="icon icon-link"></span></a>Алгоритм Белмана-Форда</h3>
<p>Как найти кратчайший путь? Можно просто релаксировать все рёбра случайным образом бесконечно много раз, и найдётся подпоследовательность релаксаций, которая найдёт мне кратчайший путь.</p>
<p>Теперь же хочется делать как можно меньше релаксаций, и чтобы там всё так же осталась подпоследовательность рёбер для нашего кратчайшего путя.</p>
<p>Прорелаксируем все рёбра в том порядке, в котором они пронумерованы: 1, 2, 3, ...; потом ещё раз: 1, 2, 3, ...; Так нужно делать <span class="inlineMath">$|V| - 1$</span> раз (длина самого длинного простого пути в графе). <code>pi = 7, 5, 4, 13, 21, 2</code> — на каждой итерации релаксации, мы прорелаксируем сначала <code>7</code>, потом <code>5</code>, ..., последнюю вершину пути.</p>
<pre><code class="language-python">for v in V:
  d[v] = inf

d[s] = 0
for i = 1 to |V| - 1:
  for (u, v) in E:
    if d[v] > d[u] + w(u, v):
       d[v] = d[u] + w(u, v)
       prev[v] = u  # для восстановления пути
</code></pre>
<p><strong>Утверждение</strong>: алгоритм корректный. Нужно доказать, что <span class="inlineMath">$\forall v: d[v] = dist(s, v)$</span>. Посмотрим на кратчайший путь от <span class="inlineMath">$s$</span> до <span class="inlineMath">$v$</span>, в нашей последовательности релаксаций был момент, когда мы релаксировали первое ребро, потом второе, ..., последнее, т.е. по предыдущей лемме получаем, что путь будет кратчайшим.</p>
<p>На циклах с отрицательными дугами не работает. Теперь зададимся вопросом: как определить наличие отрицательного цикла? Можно сделать следующее: запустим алгоритм Беллмана-Форда с <span class="inlineMath">$V$</span> итерациями. И на последнем шаге посмотрим, изменится ли значение — по идее, там не должно ничего измениться (релаксация может только улучшить расстояния, а мы уже посчитали все оптимальные расстояния на шаге <span class="inlineMath">$|V|-1$</span>). Если всё же изменилось — вот он цикл отрицательной длины.</p>
<p><strong>Утверждение</strong>: если отрицательных циклов нет <span class="inlineMath">$\Rightarrow$</span> на последней итерации <span class="inlineMath">$(= |V|)$</span>, массив <span class="inlineMath">$d$</span> не изменится.</p>
<p><strong>Утверждение</strong>: если есть отрицательный цикл, то массив <span class="inlineMath">$d$</span> обязательно (гарантированно) изменится.</p>
<p>Если делать не <span class="inlineMath">$V$</span> итераций а <span class="inlineMath">$\infty$</span>, то релаксации будут бесконечно долго уменьшать <span class="inlineMath">$d$</span>. Если на итерации <span class="inlineMath">$k$</span> ничего не изменилось, тогда ничего не изменится на итерации <span class="inlineMath">$k+1$</span> (стоп). То есть если у нас отрицательный цикл, то на каждой итерации будет что-то уменьшаться (иначе если что-то не изменится, то значит всё зафиксировано, т.е. не бесконечное количество шагов, т.е. нет цикла).</p>
<p>Из этого можно понять, что можно делать не ровно <span class="inlineMath">$V$</span> итераций, а даже меньше, но следить, изменилось ли что-нибудь.</p>
<p>Сложность <span class="inlineMath">$O(V \cdot E)$</span> (цикл по <span class="inlineMath">$V$</span> и цикл по <span class="inlineMath">$E$</span>). Если выходить раньше, то будет <span class="inlineMath">$O(\texttt{radius}(G, s) \cdot E)$</span>, где <span class="inlineMath">$radius(G, s)$</span> — длина самого длинного кратчайшего пути из <span class="inlineMath">$s$</span> до других вершин.</p>
<p><strong>NB</strong>. Если граф ациклический, то можно сделать топологическую сортировку и пройти по ней в порядке топ. сортировки, вычислить за линейное время.</p>
<h2 id="Расстояние-от-всех-вершин-до-всех-других"><a aria-hidden="true" href="#Расстояние-от-всех-вершин-до-всех-других"><span class="icon icon-link"></span></a>Расстояние от всех вершин до всех других</h2>
<ol>
<li>
<p>Хотим считать расстояния от вершины <span class="inlineMath">$u$</span> до <span class="inlineMath">$v$</span> через меньшие подзадачи. Определим <span class="inlineMath">$D(u, v, k)$</span> — кратчайший путь от <span class="inlineMath">$u$</span> до <span class="inlineMath">$v$</span>, который проходит через вершины <span class="inlineMath">$\{ 1, 2, \ldots, k\}$</span> (необязательно все, но имеется в виду принадлежность множеству).</p>
</li>
<li>
<p><span class="inlineMath">$D(u, v, 0) = w(u, v)$</span>, если <span class="inlineMath">$(u, v) \in E$</span>, иначе <span class="inlineMath">$\infty$</span>. Если представить куб, то его первый срез — это просто веса рёбер, то есть матрица смежности.
<br>
кратчайший путь от <span class="inlineMath">$u$</span> до <span class="inlineMath">$v$</span> проходит через <span class="inlineMath">$k$</span>, либо не проходит.
<span class="inlineMath">$D(u, v, k) = \min \{ D(u, v, k-1), D(u, k, k-1) + D(k, v, k-1) \}$</span>
где, вершина <span class="inlineMath">$k-1$</span> находится между <span class="inlineMath">$k$</span> и <span class="inlineMath">$v$</span> во втором случае.</p>
</li>
<li>
<p>Двигаемся вдоль координаты <span class="inlineMath">$k$</span>.</p>
</li>
</ol>
<p>Алгоритм Флойда-Уоршала:</p>
<pre><code class="language-python">for u = 1 to n:
  for v = 1 to n:
    d[u, v, 0] = w(u, v)  #inf, если ребра нет

for k = 1 to n:
  for u = 1 to n:
    for v = 1 to n:
      d[u, v, k] = d[u, v, k - 1]
      if d[u, v, k] > d[u, v, k-1] + d[k, v, k-1]:
        d[u, v, k] = d[u, v, k-1] + d[k, v, k-1]
</code></pre>
<p>Время <span class="inlineMath">$O(V^3)$</span>. Память <span class="inlineMath">$O(V^3)$</span>, но мы можем хранить только предыдущий слой: <span class="inlineMath">$O(V^2)$</span>.</p>
<pre><code class="language-python">for k = 1 to n:
  for u = 1 to n:
    for v = 1 to n:
      if d[u, v] > d[u, v] + d[k, v]:
        d[u, v]  = d[u, v] + d[k, v]
</code></pre>
<p>Можно хранить <span class="inlineMath">$prev[u, v]$</span>, которая хранит вершину перед <span class="inlineMath">$v$</span>. И при присваивании меняем <span class="inlineMath">$prev$</span>.</p>
<pre><code class="language-python"># init
if (u, w) in E:
  prev[u, v] = u

# loop
if d[u, v] > d[u, v] + d[k, v]:
  d[u, v]  = d[u, v] + d[k, v]
  prev[u, v] = prev[k, v]
</code></pre>
<p>Отрицательные рёбра норм, мы нигде не пользовались фактом, что их нет.</p>
<p>Отрицательные циклы можно детектировать, если на диагонали (кроме нулей), появятся отрицательные числа — то есть мы из вершины прошли в саму себя же.</p>
<script>
var terms = {"\u0430\u0446\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0433\u0440\u0430\u0444": {"wiki": {"title": "\u041d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0439 \u0430\u0446\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0433\u0440\u0430\u0444", "extract": "\u041d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0439 \u0430\u0446\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0433\u0440\u0430\u0444 (\u043e\u0440\u0438\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0430\u0446\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0433\u0440\u0430\u0444, DAG \u043e\u0442 \u0430\u043d\u0433\u043b.\u00a0directed acyclic graph)\u00a0\u2014 \u043e\u0440\u0433\u0440\u0430\u0444, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0435 \u0446\u0438\u043a\u043b\u044b, \u043d\u043e \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u00ab\u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0435\u00bb \u043f\u0443\u0442\u0438, \u0432\u044b\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0438\u0437 \u043e\u0434\u043d\u043e\u0433\u043e \u0443\u0437\u043b\u0430 \u0438 \u0440\u0430\u0437\u043d\u044b\u043c\u0438 \u043f\u0443\u0442\u044f\u043c\u0438 \u043f\u0440\u0438\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0432 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u0439 \u0443\u0437\u0435\u043b.", "extract_html": "<p><b>\u041d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0439 \u0430\u0446\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0433\u0440\u0430\u0444</b> (<i>\u043e\u0440\u0438\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0430\u0446\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0433\u0440\u0430\u0444</i>, <i>DAG</i> \u043e\u0442 \u0430\u043d\u0433\u043b.\u00a0<i><span lang=\"en\" xml:lang=\"en\">directed acyclic graph</span></i>)\u00a0\u2014 \u043e\u0440\u0433\u0440\u0430\u0444, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0435 \u0446\u0438\u043a\u043b\u044b, \u043d\u043e \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u00ab\u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0435\u00bb \u043f\u0443\u0442\u0438, \u0432\u044b\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0438\u0437 \u043e\u0434\u043d\u043e\u0433\u043e \u0443\u0437\u043b\u0430 \u0438 \u0440\u0430\u0437\u043d\u044b\u043c\u0438 \u043f\u0443\u0442\u044f\u043c\u0438 \u043f\u0440\u0438\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0432 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u0439 \u0443\u0437\u0435\u043b.", "thumbnail": {"source": "https://upload.wikimedia.org/wikipedia/commons/0/08/Directed_acyclic_graph.png", "width": 260, "height": 231}, "wiki_url": "https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B0%D1%86%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B3%D1%80%D0%B0%D1%84"}, "neerc": {"title": "\u0421\u0443\u0444\u0444\u0438\u043a\u0441\u043d\u044b\u0439 \u0430\u0432\u0442\u043e\u043c\u0430\u0442", "wiki_url": "https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D1%83%D1%84%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82", "extract": "==\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435==\n\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435\n\n *\u0421\u0443\u0444\u0444\u0438\u043a\u0441\u043d\u044b\u0439 \u0430\u0432\u0442\u043e\u043c\u0430\u0442*  (\u0430\u043d\u0433\u043b. ''suffix automaton'', ''directed acyclic word graph'') \u2014 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u0414\u041a\u0410, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0432\u0441\u0435 \u0441\u0443\u0444\u0444\u0438\u043a\u0441\u044b \u0441\u0442\u0440\u043e\u043a\u0438 \u0438 \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u0445.", "extract_html": "\t<p>\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435<br />\n\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435</p>\n\n <b>\u0421\u0443\u0444\u0444\u0438\u043a\u0441\u043d\u044b\u0439 \u0430\u0432\u0442\u043e\u043c\u0430\u0442</b>  (\u0430\u043d\u0433\u043b. &#8216;&#8216;suffix automaton&#8217;&#8216;, &#8216;&#8216;directed acyclic word graph&#8217;&#8216;) \u2014 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 <span class=\"caps\">\u0414\u041a\u0410</span>, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0432\u0441\u0435 \u0441\u0443\u0444\u0444\u0438\u043a\u0441\u044b \u0441\u0442\u0440\u043e\u043a\u0438 \u0438 \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u0445.", "thumbnail": {"source": "https://neerc.ifmo.ru/wiki/images/8/89/Suffix_automaton_ex.png", "width": "540", "height": "140"}}}};
</script>

      
      <div class="navigation">
          <a href="https://xamgore.github.io/au-conspectus/lec_08.html">← взад</a>
          <a href="index.html">на главную</a>
          <a href="None"></a>
      </div>
      
  </article>
<script src="assets/popup.js"></script>
</body>
</html>